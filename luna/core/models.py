"""Pydantic models for type-safe data handling.

This module defines all data structures used throughout Luna RPG v4,
ensuring type safety and validation across the entire application.
"""
from __future__ import annotations

from datetime import datetime
from enum import Enum, auto
from typing import Any, Dict, List, Literal, Optional, Set

from pydantic import BaseModel, ConfigDict, Field, field_validator


# =============================================================================
# Enums
# =============================================================================

class CompositionType(str, Enum):
    """Camera framing types for image generation."""
    CLOSE_UP = "close_up"
    MEDIUM_SHOT = "medium_shot"
    WIDE_SHOT = "wide_shot"
    GROUP = "group"
    SCENE = "scene"


class QuestStatus(str, Enum):
    """Quest lifecycle states."""
    NOT_STARTED = "not_started"
    ACTIVE = "active"
    COMPLETED = "completed"
    FAILED = "failed"
    HIDDEN = "hidden"


class BehaviorType(str, Enum):
    """Player behavior patterns tracked by personality engine."""
    AGGRESSIVE = "aggressive"
    SHY = "shy"
    ROMANTIC = "romantic"
    DOMINANT = "dominant"
    SUBMISSIVE = "submissive"
    CURIOUS = "curious"
    TEASING = "teasing"
    PROTECTIVE = "protective"


class OutfitComponent(str, Enum):
    """Clothing components for outfit tracking."""
    TOP = "top"                    # shirts, t-shirts, blouses, etc
    BOTTOM = "bottom"              # pants, skirt, shorts, etc
    SHOES = "shoes"                # barefoot, sandals, sneakers, boots, etc
    OUTERWEAR = "outerwear"        # jacket, coat, cardigan, etc
    ACCESSORIES = "accessories"    # glasses, jewelry, hats, etc
    SPECIAL = "special"            # towel, apron, etc (overrides others)


class PowerDynamic(str, Enum):
    """Relationship power balance."""
    PLAYER_DOMINANT = "player_dominant"
    EQUAL = "equal"
    NPC_DOMINANT = "npc_dominant"


class TimeOfDay(str, Enum):
    """Game time periods."""
    MORNING = "Morning"
    AFTERNOON = "Afternoon"
    EVENING = "Evening"
    NIGHT = "Night"


class ApproachType(str, Enum):
    """NPC interaction approaches."""
    STANDARD = "standard"
    PHYSICAL_ACTION = "physical_action"
    QUESTION = "question"
    CHOICE = "choice"


# =============================================================================
# Base Models
# =============================================================================

class LunaBaseModel(BaseModel):
    """Base model with common configuration."""
    
    model_config = ConfigDict(
        strict=True,
        validate_assignment=True,
        extra="forbid",
        use_enum_values=True,
    )


# =============================================================================
# Game State Models
# =============================================================================

class PlayerState(LunaBaseModel):
    """Player character state."""
    
    name: str = Field(default="Protagonist")
    age: int = Field(default=18, ge=16, le=99)
    background: str = Field(default="New student")
    
    # Stats (0-100)
    strength: int = Field(default=10, ge=0, le=100)
    mind: int = Field(default=10, ge=0, le=100)
    charisma: int = Field(default=10, ge=0, le=100)
    
    # Resources
    gold: int = Field(default=0, ge=0)
    hp: int = Field(default=20, ge=0)
    max_hp: int = Field(default=20, ge=1)
    
    # Progression
    inventory: List[str] = Field(default_factory=list)
    flags: Dict[str, Any] = Field(default_factory=dict)


class OutfitState(LunaBaseModel):
    """Detailed outfit state for a character.
    
    Tracks both structured components (for SD prompt generation)
    and free-form description (for LLM context).
    """
    
    style: str = Field(default="default")
    """Wardrobe style key (casual, formal, etc)."""
    
    description: str = Field(default="")
    """Free-form description generated by LLM."""
    
    components: Dict[str, str] = Field(default_factory=dict)
    """Structured components: {component_type: value}.
    
    Examples:
        {"top": "t-shirt", "bottom": "jeans", "shoes": "none"}
        {"special": "towel", "shoes": "barefoot"}
    """
    
    last_updated_turn: int = Field(default=0, ge=0)
    """Turn when this outfit was generated/updated."""
    
    is_special: bool = Field(default=False)
    """If True, this is a special state (towel, etc) that overrides normal clothing."""
    
    def get_component(self, component: OutfitComponent | str, default: str = "") -> str:
        """Get a specific component value."""
        key = component.value if isinstance(component, OutfitComponent) else component
        return self.components.get(key, default)
    
    def set_component(self, component: OutfitComponent | str, value: str) -> None:
        """Set a component value."""
        key = component.value if isinstance(component, OutfitComponent) else component
        self.components[key] = value
    
    def to_prompt_string(self) -> str:
        """Convert to string for LLM context."""
        if self.is_special:
            return f"[Special: {self.description}]"
        if self.description:
            return self.description
        return f"wearing {self.style} clothes"


class NPCState(LunaBaseModel):
    """Non-player character state."""
    
    name: str
    location: str = Field(default="Unknown")
    outfit: OutfitState = Field(default_factory=OutfitState)
    affinity: int = Field(default=0, ge=0, le=100)
    
    # Personality tracking
    emotional_state: str = Field(default="default")
    last_interaction_turn: int = Field(default=0, ge=0)
    
    # Flags specifici NPC
    flags: Dict[str, Any] = Field(default_factory=dict)


class GameState(LunaBaseModel):
    """Complete game state for a session."""
    
    model_config = ConfigDict(from_attributes=True)
    
    # Identity
    session_id: Optional[int] = None
    world_id: str
    
    # Time & Location
    turn_count: int = Field(default=0, ge=0)
    time_of_day: TimeOfDay = Field(default=TimeOfDay.MORNING)
    current_location: str = Field(default="Unknown")
    
    # Active companion
    active_companion: str
    companion_outfit: str = Field(default="default")  # Deprecated: use companion_outfits
    
    # Outfit states per companion
    companion_outfits: Dict[str, OutfitState] = Field(default_factory=dict)
    """Outfit state for each companion by name."""
    
    # Player
    player: PlayerState = Field(default_factory=PlayerState)
    
    # NPCs
    npc_states: Dict[str, NPCState] = Field(default_factory=dict)
    
    # Relationships (affinity con tutti i companion)
    affinity: Dict[str, int] = Field(default_factory=dict)
    
    # Quest progress
    active_quests: List[str] = Field(default_factory=list)
    completed_quests: List[str] = Field(default_factory=list)
    quest_flags: Dict[str, Any] = Field(default_factory=dict)
    
    # General flags (used by story director, quests, location system)
    flags: Dict[str, Any] = Field(default_factory=dict)
    
    # Metadata
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    
    @field_validator("affinity")
    @classmethod
    def clamp_affinity(cls, v: Dict[str, int]) -> Dict[str, int]:
        """Ensure all affinity values are within 0-100 range."""
        return {k: max(0, min(100, val)) for k, val in v.items()}
    
    # ========================================================================
    # Outfit Management Helpers
    # ========================================================================
    
    def get_outfit(self, companion_name: Optional[str] = None) -> OutfitState:
        """Get outfit state for a companion (defaults to active)."""
        name = companion_name or self.active_companion
        if name not in self.companion_outfits:
            self.companion_outfits[name] = OutfitState()
        return self.companion_outfits[name]
    
    def set_outfit(self, outfit: OutfitState, companion_name: Optional[str] = None) -> None:
        """Set outfit state for a companion (defaults to active)."""
        name = companion_name or self.active_companion
        self.companion_outfits[name] = outfit
        # Sync legacy field for compatibility
        if name == self.active_companion:
            self.companion_outfit = outfit.style
    
    def get_active_outfit_description(self) -> str:
        """Get outfit description for active companion (for prompts)."""
        outfit = self.get_outfit()
        return outfit.to_prompt_string()


# =============================================================================
# LLM Response Models
# =============================================================================

class OutfitUpdate(LunaBaseModel):
    """Outfit update from LLM - can be partial or complete."""
    
    style: Optional[str] = None
    """Wardrobe style (casual, formal, etc). If set, triggers new outfit generation."""
    
    description: Optional[str] = None
    """Complete outfit description. If set, overrides current description."""
    
    modify_components: Dict[str, str] = Field(default_factory=dict)
    """Partial modifications: {component: new_value}.
    
    Examples:
        {"shoes": "none"} - remove shoes
        {"top": "t-shirt"} - change top
    """
    
    is_special: Optional[bool] = None
    """If True, this is a special state (towel, etc)."""


class StateUpdate(LunaBaseModel):
    """State changes proposed by LLM (validated by engine)."""
    
    location: Optional[str] = None
    time_of_day: Optional[TimeOfDay] = None
    current_outfit: Optional[str] = None  # Legacy: style name only
    outfit_update: Optional[OutfitUpdate] = None  # New: detailed outfit update
    
    # Affinity changes (character -> delta)
    affinity_change: Dict[str, int] = Field(default_factory=dict)
    
    # Quest & flags
    set_flags: Dict[str, Any] = Field(default_factory=dict)
    new_quests: List[str] = Field(default_factory=list)
    complete_quests: List[str] = Field(default_factory=list)
    
    # NPC updates
    npc_location: Optional[str] = None
    npc_outfit: Optional[str] = None
    npc_emotion: Optional[str] = None
    
    # Fact for memory
    new_fact: Optional[str] = None
    
    @field_validator("affinity_change")
    @classmethod
    def clamp_affinity_change(cls, v: Dict[str, int]) -> Dict[str, int]:
        """Clamp affinity changes to -5/+5 range per turn."""
        return {k: max(-5, min(5, val)) for k, val in v.items()}


class LLMResponse(LunaBaseModel):
    """Structured response from LLM."""
    
    model_config = ConfigDict(
        strict=False,  # Allow string to enum conversion
        validate_assignment=True,
        extra="ignore",
        use_enum_values=True,
    )
    
    # Narrative
    text: str = Field(description="Narrative text in Italian")
    
    # Visual generation
    visual_en: str = Field(default="", description="Visual description for image generation")
    tags_en: List[str] = Field(default_factory=list, description="SD tags for image generation")
    body_focus: Optional[str] = Field(default=None, description="Body part in focus")
    
    # Multi-character support
    secondary_characters: List[str] = Field(
        default_factory=list, 
        description="Other characters visible in the scene (besides active companion)"
    )
    
    # Technical - accept both enum and string
    approach_used: str = Field(default="standard")
    composition: str = Field(default="medium_shot")
    
    # State updates (will be validated)
    updates: StateUpdate = Field(default_factory=StateUpdate)
    
    # Metadata
    raw_response: Optional[str] = Field(default=None, exclude=True)
    provider: Optional[str] = Field(default=None, exclude=True)
    
    @property
    def is_multi_character(self) -> bool:
        """True if scene has multiple characters."""
        return len(self.secondary_characters) > 0


class SceneAnalysis(LunaBaseModel):
    """Semantic analysis of current scene."""
    
    primary_subject: Optional[str] = Field(
        default=None,
        description="Main character in focus, None if group shot"
    )
    secondary_subjects: List[str] = Field(
        default_factory=list,
        description="Characters visually present but not focus"
    )
    background_mentions: List[str] = Field(
        default_factory=list,
        description="Characters mentioned but not in visual scene"
    )
    
    composition_type: CompositionType = Field(default=CompositionType.MEDIUM_SHOT)
    action_focus: str = Field(default="", description="Main action described")
    body_focus: Optional[str] = Field(default=None)
    
    reasoning: str = Field(default="", description="Explanation of analysis")
    
    @property
    def is_multi_character(self) -> bool:
        """True if 2+ characters are visually present."""
        count = len(self.secondary_subjects)
        if self.primary_subject:
            count += 1
        return count >= 2
    
    def get_all_present_subjects(self) -> List[str]:
        """Return all visually present characters."""
        subjects = []
        if self.primary_subject:
            subjects.append(self.primary_subject)
        subjects.extend(self.secondary_subjects)
        return subjects


# =============================================================================
# Quest System Models
# =============================================================================

class QuestCondition(LunaBaseModel):
    """Condition for quest activation or stage transition."""
    
    type: Literal[
        "affinity", "location", "time", "flag", "turn_count",
        "inventory", "action", "companion"
    ]
    target: Optional[str] = None
    operator: Literal["eq", "gt", "lt", "gte", "lte", "contains"] = "eq"
    value: Any = None
    pattern: Optional[str] = None  # For regex matching (action type)


class QuestAction(LunaBaseModel):
    """Action executed on quest events."""
    
    action: Literal[
        "set_location", "set_outfit", "set_flag", "add_flag",
        "change_affinity", "increment_stat", "set_emotional_state",
        "set_time", "unlock_achievement", "start_quest", "complete_quest"
    ]
    character: Optional[str] = None
    target: Optional[str] = None
    key: Optional[str] = None
    value: Any = None
    outfit: Optional[str] = None
    stat: Optional[str] = None
    achievement: Optional[str] = None
    quest_id: Optional[str] = None


class QuestTransition(LunaBaseModel):
    """Transition between quest stages."""
    
    condition: str  # Reference to condition name
    target_stage: str  # Stage ID or _complete/_fail


class QuestStage(LunaBaseModel):
    """Single stage within a quest."""
    
    title: str
    description: str = ""
    narrative_prompt: str = ""  # Context for LLM
    
    # Events
    on_enter: List[QuestAction] = Field(default_factory=list)
    on_exit: List[QuestAction] = Field(default_factory=list)
    
    # Exit conditions
    exit_conditions: List[QuestCondition] = Field(default_factory=list)
    transitions: List[QuestTransition] = Field(default_factory=list)
    
    # Timeout
    max_turns: Optional[int] = None


class QuestRewards(LunaBaseModel):
    """Rewards for completing a quest."""
    
    affinity: Dict[str, int] = Field(default_factory=dict)
    items: List[str] = Field(default_factory=list)
    flags: Dict[str, Any] = Field(default_factory=dict)
    unlock_quests: List[str] = Field(default_factory=list)


class QuestDefinition(LunaBaseModel):
    """Complete quest definition."""
    
    id: str
    title: str
    description: str = ""
    character: Optional[str] = None  # Associated companion
    
    # Activation
    activation_type: Literal["auto", "manual", "trigger"] = "auto"
    activation_conditions: List[QuestCondition] = Field(default_factory=list)
    trigger_event: Optional[str] = None
    hidden: bool = False
    
    # Stages
    stages: Dict[str, QuestStage] = Field(default_factory=dict)
    start_stage: str = "start"
    
    # Rewards
    rewards: QuestRewards = Field(default_factory=QuestRewards)
    
    # Requirements
    required_quests: List[str] = Field(default_factory=list)
    
    @property
    def is_linear(self) -> bool:
        """True if quest has simple linear progression."""
        return len(self.stages) <= 2


class QuestInstance(LunaBaseModel):
    """Runtime instance of a quest for a save."""
    
    quest_id: str
    status: QuestStatus = QuestStatus.NOT_STARTED
    current_stage_id: Optional[str] = None
    stage_data: Dict[str, Any] = Field(default_factory=dict)
    
    # Timing
    started_at: int = Field(default=0, ge=0)  # Turn count
    completed_at: Optional[int] = None
    
    # Progress tracking
    custom_data: Dict[str, Any] = Field(default_factory=dict)


# =============================================================================
# Personality System Models
# =============================================================================

class TraitIntensity(str, Enum):
    """Intensity of behavioral traits."""
    SUBTLE = "subtle"
    MODERATE = "moderate"
    STRONG = "strong"


class BehavioralMemory(LunaBaseModel):
    """Memory of player behavior patterns."""
    
    trait: BehaviorType
    occurrences: int = Field(default=0, ge=0)
    last_turn: int = Field(default=0, ge=0)
    intensity: TraitIntensity = TraitIntensity.SUBTLE
    
    def update(self, turn: int) -> None:
        """Update memory with new occurrence."""
        self.occurrences += 1
        self.last_turn = turn
        if self.occurrences > 5:
            self.intensity = TraitIntensity.STRONG
        elif self.occurrences > 2:
            self.intensity = TraitIntensity.MODERATE


class Impression(LunaBaseModel):
    """NPC impression of player (-100 to +100)."""
    
    trust: int = Field(default=0, ge=-100, le=100)
    attraction: int = Field(default=0, ge=-100, le=100)
    fear: int = Field(default=0, ge=-100, le=100)
    curiosity: int = Field(default=50, ge=-100, le=100)
    dominance_balance: int = Field(default=0, ge=-100, le=100)
    
    def get_dominant_emotion(self) -> str:
        """Return the strongest emotional impression."""
        values = {
            "trust": self.trust,
            "attraction": self.attraction,
            "fear": self.fear,
            "curiosity": self.curiosity,
        }
        return max(values, key=values.get)


class NPCLink(LunaBaseModel):
    """Relationship between two NPCs."""
    
    target_npc: str
    rapport: int = Field(default=0, ge=-100, le=100)
    jealousy_sensitivity: float = Field(default=0.5, ge=0.0, le=1.0)
    awareness_of_player: int = Field(default=0, ge=0, le=100)


class PersonalityState(LunaBaseModel):
    """Complete personality state for a character."""
    
    character_name: str
    
    # Behavioral tracking
    behavioral_memory: Dict[BehaviorType, BehavioralMemory] = Field(default_factory=dict)
    
    # Current impression
    impression: Impression = Field(default_factory=Impression)
    
    # Relations with other NPCs
    npc_links: Dict[str, NPCLink] = Field(default_factory=dict)
    
    # Calculated
    detected_archetype: Optional[str] = None
    archetype_cache_turn: int = Field(default=-1, ge=-1)


# =============================================================================
# World Models
# =============================================================================

class LocationState(str, Enum):
    """Dynamic states a location can be in."""
    NORMAL = "normal"
    CROWDED = "crowded"           # Many people
    EMPTY = "empty"               # Deserted
    LOCKED = "locked"             # Inaccessible
    DAMAGED = "damaged"           # After event/fight
    DECORATED = "decorated"       # For event/party
    DARK = "dark"                 # Lights off
    CLEANING = "cleaning"         # Being cleaned


class Location(LunaBaseModel):
    """Game location definition with full immersion features."""
    
    id: str
    name: str
    description: str = ""
    
    # Visual generation
    visual_style: str = ""
    lighting: str = ""
    
    # Navigation & Hierarchy
    connected_to: List[str] = Field(default_factory=list)
    """Direct connections to other locations."""
    
    parent_location: Optional[str] = None
    """Parent location (e.g., 'school_bathroom' has parent 'school')."""
    
    sub_locations: List[str] = Field(default_factory=list)
    """Child locations within this one."""
    
    aliases: List[str] = Field(default_factory=list)
    """Alternative names player might use."""
    
    # Access control
    requires_parent: bool = False
    """If True, player must be in parent_location to enter."""
    
    requires_item: Optional[str] = None
    """Item needed to enter (e.g., 'key' for locked room)."""
    
    requires_flag: Optional[str] = None
    """Game flag needed (e.g., 'knows_secret_passage')."""
    
    hidden: bool = False
    """If True, not shown until discovered."""
    
    discovery_hint: str = ""
    """Hint shown when nearby (e.g., 'You hear strange noises...')."""
    
    # Time-based availability
    available_times: List[TimeOfDay] = Field(default_factory=lambda: list(TimeOfDay))
    """When this location is accessible. Empty = always."""
    
    closed_description: str = ""
    """Description when closed/locked."""
    
    # NPCs
    available_characters: List[str] = Field(default_factory=list)
    """NPCs that can be found here."""
    
    companion_can_follow: bool = True
    """If False, companion refuses to enter."""
    
    companion_refuse_message: str = ""
    """What companion says if they can't follow."""
    
    # Dynamic state
    dynamic_descriptions: Dict[str, str] = Field(default_factory=dict)
    """Alternative descriptions based on state (keys: 'crowded', 'empty', 'locked', etc)."""
    
    time_descriptions: Dict[TimeOfDay, str] = Field(default_factory=dict)
    """Descriptions that change based on time of day."""


class LocationInstance(LunaBaseModel):
    """Runtime state of a location in a game session."""
    
    location_id: str
    current_state: LocationState = LocationState.NORMAL
    discovered: bool = True
    
    # Dynamic modifications
    custom_description: str = ""
    """Override description (e.g., after player messes up the room)."""
    
    flags: Dict[str, Any] = Field(default_factory=dict)
    """Location-specific flags (e.g., 'lights_off': True)."""
    
    # NPC presence
    npcs_present: List[str] = Field(default_factory=list)
    """Currently present NPCs."""
    
    def get_effective_description(
        self,
        location_def: Location,
        time_of_day: TimeOfDay,
    ) -> str:
        """Get description considering state and time."""
        # Priority: custom > dynamic state > time-based > default
        if self.custom_description:
            return self.custom_description
        
        if self.current_state in location_def.dynamic_descriptions:
            return location_def.dynamic_descriptions[self.current_state]
        
        if time_of_day in location_def.time_descriptions:
            return location_def.time_descriptions[time_of_day]
        
        return location_def.description


class TimeSlot(LunaBaseModel):
    """Time slot definition."""
    
    time_of_day: TimeOfDay
    lighting: str = ""  # For visual generation
    ambient_description: str = ""


class ScheduleEntry(LunaBaseModel):
    """NPC schedule entry."""
    
    time_of_day: TimeOfDay
    location: str
    outfit: str = "default"
    activity: str = ""


class LocationTransition(LunaBaseModel):
    """Narrative transition between locations."""
    
    from_location: str
    to_location: str
    
    # Narrative
    description: str
    """Text shown during transition (1-2 sentences)."""
    
    mood: str = "neutral"
    """neutral, tense, romantic, scary, etc."""
    
    # Conditions
    requires_companion: bool = False
    """If True, companion must be present for this transition."""
    
    companion_variant: str = ""
    """Alternative text when companion is present."""
    
    # Dynamic based on time
    time_variants: Dict[TimeOfDay, str] = Field(default_factory=dict)
    """Different descriptions based on time."""


class MovementRequest(LunaBaseModel):
    """Player request to move to a location."""
    
    target_location: str
    """Requested location ID or alias."""
    
    intent_description: str = ""
    """How player described the movement (for flavor)."""


class MovementResponse(LunaBaseModel):
    """Response to a movement request."""
    
    success: bool
    
    # If successful
    new_location: Optional[str] = None
    transition_text: str = ""
    
    # If blocked
    block_reason: str = ""  # "locked", "companion_refused", "llm_denied"
    block_description: str = ""
    
    # Alternative suggestions
    alternatives: List[str] = Field(default_factory=list)


class WardrobeDefinition(LunaBaseModel):
    """Definition of a wardrobe style/outfit."""
    
    description: str = ""
    """Description of the style (e.g., 'Casual clothes for relaxing')."""
    
    special: bool = False
    """If True, this is a special state (towel, apron, etc)."""


class EmotionalStateDefinition(LunaBaseModel):
    """Definition of an emotional state for a companion."""
    
    description: str = ""
    """Description of the emotional state."""
    
    dialogue_tone: str = ""
    """How the character speaks in this state."""
    
    trigger_flags: List[str] = Field(default_factory=list)
    """Flags that trigger this emotional state."""


class CompanionDefinition(LunaBaseModel):
    """Static definition of a companion character."""
    
    name: str
    role: str = ""
    age: int = Field(default=21, ge=16)  # Changed from 18 to 16 for school settings
    base_personality: str = ""
    
    # Visual
    base_prompt: str = ""  # LoRA + trigger words
    physical_description: str = ""  # Physical appearance description
    default_outfit: str = "default"
    
    # Outfit System V2: can be simple strings (legacy) or WardrobeDefinition objects
    wardrobe: Dict[str, Any] = Field(default_factory=dict)
    
    # Personality system
    emotional_states: Dict[str, Any] = Field(default_factory=dict)
    affinity_tiers: Dict[str, Dict[str, Any]] = Field(default_factory=dict)
    
    # Dialogue
    dialogue_tone: Dict[str, Any] = Field(default_factory=dict)
    
    # Schedule
    schedule: Dict[TimeOfDay, ScheduleEntry] = Field(default_factory=dict)
    
    # Relations
    relations: Dict[str, Dict[str, Any]] = Field(default_factory=dict)


class NarrativeArc(LunaBaseModel):
    """Complete narrative structure for a world.
    
    Defines the story beats that give structure to the AI-generated narrative.
    """
    
    premise: str = Field(
        default="",
        description="Core premise that must always be respected"
    )
    
    themes: List[str] = Field(
        default_factory=list,
        description="Themes to explore throughout the story"
    )
    
    beats: List[StoryBeat] = Field(
        default_factory=list,
        description="Mandatory story beats"
    )
    
    # Narrative constraints
    hard_limits: List[str] = Field(
        default_factory=list,
        description="Absolute constraints (e.g., 'no character death')"
    )
    
    soft_guidelines: List[str] = Field(
        default_factory=list,
        description="Guidelines (e.g., 'avoid repetitive dialogue')"
    )


class MilestoneDefinition(LunaBaseModel):
    """Milestone/achievement definition for a world."""
    
    id: str
    name: str
    description: str = ""
    icon: str = ""
    condition: Dict[str, Any] = Field(default_factory=dict)
    """Condition dict with keys like 'affinity', 'flag', etc."""


class EndgameCondition(LunaBaseModel):
    """Single endgame victory condition."""
    
    type: str = "companion_conquered"
    target: str
    requires: List[Dict[str, Any]] = Field(default_factory=list)


class EndgameDefinition(LunaBaseModel):
    """Endgame/victory conditions for a world."""
    
    description: str = ""
    victory_conditions: List[EndgameCondition] = Field(default_factory=list)


class GlobalEventEffect(LunaBaseModel):
    """Effect of a global event."""
    
    duration: int = Field(default=3, ge=1)
    location_modifiers: List[Dict[str, Any]] = Field(default_factory=list)
    visual_tags: List[str] = Field(default_factory=list)
    atmosphere_change: str = ""
    affinity_multiplier: float = Field(default=1.0, ge=0.0)
    on_start: List[Dict[str, Any]] = Field(default_factory=list)
    on_end: List[Dict[str, Any]] = Field(default_factory=list)


class GlobalEventDefinition(LunaBaseModel):
    """Global event definition (weather, situations, etc)."""
    
    id: str
    title: str = ""
    description: str = ""
    trigger_type: str = "random"  # random, conditional
    trigger_chance: float = Field(default=0.1, ge=0.0, le=1.0)
    trigger_conditions: List[Dict[str, Any]] = Field(default_factory=list)
    allowed_times: List[str] = Field(default_factory=list)
    effects: GlobalEventEffect = Field(default_factory=GlobalEventEffect)
    narrative_prompt: str = ""


class WorldDefinition(LunaBaseModel):
    """Complete world definition."""
    
    id: str
    name: str
    genre: str = "Visual Novel"
    description: str = ""
    lore: str = ""
    
    # Content
    locations: Dict[str, Location] = Field(default_factory=dict)
    companions: Dict[str, CompanionDefinition] = Field(default_factory=dict)
    time_slots: Dict[TimeOfDay, TimeSlot] = Field(default_factory=dict)
    
    # Quests
    quests: Dict[str, QuestDefinition] = Field(default_factory=dict)
    
    # Narrative structure
    narrative_arc: NarrativeArc = Field(default_factory=NarrativeArc)
    
    # Gameplay systems configuration
    gameplay_systems: Dict[str, Dict[str, Any]] = Field(default_factory=dict)
    
    # NPC detection
    female_hints: List[str] = Field(default_factory=list)
    male_hints: List[str] = Field(default_factory=list)
    
    # Milestones/achievements
    milestones: Dict[str, MilestoneDefinition] = Field(default_factory=dict)
    
    # Endgame conditions
    endgame: Optional[EndgameDefinition] = None
    
    # Global events
    global_events: Dict[str, GlobalEventDefinition] = Field(default_factory=dict)
    
    # Player character default stats
    player_character: Dict[str, Any] = Field(default_factory=dict)


# =============================================================================
# Media Generation Models
# =============================================================================

class ImagePrompt(LunaBaseModel):
    """Structured image generation prompt."""
    
    positive: str
    negative: str = ""
    width: int = Field(default=896, ge=512, le=2048)
    height: int = Field(default=1152, ge=512, le=2048)
    steps: int = Field(default=24, ge=1, le=100)
    seed: Optional[int] = None
    
    # LoRA configuration
    lora_stack: List[Dict[str, Any]] = Field(default_factory=list)


class VideoPrompt(LunaBaseModel):
    """Structured video generation prompt."""
    
    positive: str
    negative: str = ""
    width: int = Field(default=512, ge=256, le=1024)
    height: int = Field(default=768, ge=256, le=1024)
    frames: int = Field(default=81, ge=16, le=121)
    motion_speed: int = Field(default=6, ge=1, le=10)


# =============================================================================
# Memory Models
# =============================================================================

class MemoryEntry(LunaBaseModel):
    """Single memory entry."""
    
    id: Optional[int] = None
    type: Literal["summary", "fact", "event"] = "fact"
    content: str
    turn_count: int = Field(ge=0)
    created_at: Optional[datetime] = None
    importance: int = Field(default=5, ge=1, le=10)


class ConversationMessage(LunaBaseModel):
    """Single conversation message."""
    
    role: Literal["user", "assistant", "system"]
    content: str
    turn_number: int = Field(ge=0)
    
    # Metadata for AI generation
    visual_en: Optional[str] = None
    tags_en: Optional[List[str]] = None
    
    timestamp: Optional[datetime] = None


# =============================================================================
# Configuration Models
# =============================================================================

class AppConfig(LunaBaseModel):
    """Application configuration."""
    
    model_config = ConfigDict(extra="ignore")
    
    # Execution
    execution_mode: Literal["LOCAL", "RUNPOD"] = "LOCAL"
    log_level: Literal["DEBUG", "INFO", "WARNING", "ERROR"] = "INFO"
    
    # LLM
    llm_provider: Literal["gemini", "moonshot", "openai", "ollama"] = "gemini"
    gemini_api_key: Optional[str] = None
    moonshot_api_key: Optional[str] = None
    openai_api_key: Optional[str] = None
    
    # RunPod
    runpod_id: Optional[str] = None
    runpod_api_key: Optional[str] = None
    
    # Local services
    local_sd_url: str = "http://127.0.0.1:7860"
    local_comfy_url: str = "http://127.0.0.1:8188"
    
    # Database
    database_url: str = "sqlite+aiosqlite:///storage/saves/luna_v4.db"
    
    # Media
    google_credentials_path: str = "google_credentials.json"
    video_enabled: bool = False
    video_motion_speed: int = Field(default=6, ge=1, le=10)
    
    # Game
    memory_history_limit: int = Field(default=50, ge=10, le=200)
    image_width: int = Field(default=896, ge=512, le=2048)
    image_height: int = Field(default=1152, ge=512, le=2048)
    image_steps: int = Field(default=24, ge=1, le=100)
    
    @property
    def is_runpod(self) -> bool:
        """True if running in RunPod mode."""
        return self.execution_mode == "RUNPOD"
    
    @property
    def video_available(self) -> bool:
        """True if video generation is available."""
        return self.is_runpod and self.video_enabled and self.runpod_id is not None
    
    @property
    def comfy_url(self) -> Optional[str]:
        """ComfyUI URL based on execution mode."""
        if self.is_runpod and self.runpod_id:
            return f"https://{self.runpod_id}-8188.proxy.runpod.net"
        return self.local_comfy_url
    
    @property
    def sd_url(self) -> str:
        """Stable Diffusion URL based on execution mode."""
        if self.is_runpod and self.runpod_id:
            return f"https://{self.runpod_id}-7860.proxy.runpod.net"
        return self.local_sd_url


# =============================================================================
# Story Beats System - Narrative Structure
# =============================================================================

class StoryBeat(LunaBaseModel):
    """A mandatory narrative moment that must occur in the story.
    
    Story beats provide structure while allowing AI freedom in execution.
    Python controls WHEN they happen, AI controls HOW.
    """
    
    id: str = Field(description="Unique beat identifier")
    description: str = Field(description="What must happen in this beat")
    
    # Trigger conditions (Python evaluates these)
    trigger: str = Field(
        default="",
        description="Condition to activate (e.g., 'turn >= 10 AND affinity > 30')"
    )
    
    # Required elements that MUST appear in the narrative
    required_elements: List[str] = Field(
        default_factory=list,
        description="Elements that must be present (checked by Python)"
    )
    
    # Narrative guidance
    tone: str = Field(
        default="",
        description="Tone for this beat (e.g., 'melancholic', 'romantic')"
    )
    
    # Beat properties
    once: bool = Field(
        default=True,
        description="If true, beat can only trigger once"
    )
    priority: int = Field(
        default=5,
        ge=1,
        le=10,
        description="Priority (1=highest, 10=lowest) when multiple beats could trigger"
    )
    
    # Consequences (applied by Python after successful beat)
    consequence: Optional[str] = Field(
        default=None,
        description="State changes (e.g., 'affinity += 10, flag:x = true')"
    )


class BeatExecution(LunaBaseModel):
    """Tracks execution of a story beat in a game session.
    
    Stored in game state to track which beats have been completed.
    """
    
    beat_id: str
    triggered_at: int = Field(description="Turn when beat was triggered")
    completed: bool = False
    execution_quality: float = Field(
        default=1.0,
        ge=0.0,
        le=1.0,
        description="How well the beat was executed (validated by Python)"
    )
    
    # Store the actual narrative produced
    narrative_snapshot: str = Field(
        default="",
        description="The LLM text that fulfilled this beat"
    )
